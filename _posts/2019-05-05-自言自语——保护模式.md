---
layout:     post
title:      自言自语——保护模式
subtitle:   地址扩展&段安全
date:       2019-05-05
author:     sanbai
header-img: img/2019_05_05/desktop.jpg
catalog: true
tags:
    - 操作系统，保护模式
---

## What？

暂时无法给出答案


## Why——为什么需要保护模式？
在实模式下，最主要存在两个问题：地址空间下（1MB）和内存（段）访问无保护。虽然使用了（x4）的方式使原本只能访问2^16(64KB)地址空间扩展到了2^20(1MB),但是这并不是长久之计。到了32位时代，那不是段寄存器的值左移2位能够解决的，而是左移16位。同时，64KB的段对现代程序来说实在过于吝啬。诚然，可以为一个程序分配多个段来满足其需求，但是势必增加了段管理的复杂性，而为何不直接将寄存器扩展至32位（当然出乎意料的是段寄存器并没有得到扩展，因为其角色发生了一定的转变————段选择子。随之引入段便是段描述符（SD））。可以看看实模式和保护模式寄存器扩展情况。
![](https://github.com/null-007/null-007.github.io/tree/master/img/2019_05_05/register-32.png)

而对于内存访问无保护的问题，首先还是需要想想实模式下是如何访问内存的。[段基址:段内偏移地址]是x86系列的内存访问模式，这是沿用自x8086。可以试想，主要程序有能力修改段基基，那么它就能访问任意的内存地址。而这种能力是很容易获得的，因为实模式并未对这样的修改操作加以任何限制。我门甚至可以猜测保护模式应该具备怎样的素质，至少当前程序不能修改正在使用中的别的段；得区别代码段和数据段，代码段禁止修改；...很幸运，保护模式确实将这些素质引入了，而且比上述寥寥猜想要完善得许多。它用段描述符（SD）不仅实现了内存地址段扩展，顺带将段段安全问题也解决了。可以看看段描述符的样子：
![](https://github.com/null-007/null-007.github.io/img/2019_05_05/SD.png)
首先段基址扩展到了32位，20位段界限限制了本段的大小，段界限的真正确立还需要得到粒度符号G（1B/4KB）的辅助。至于其它位，在某种规则的组织下，表达了对段访问的安全限制（此刻我并不想去了解这些细节）。

不同于实模式，段寄存器存储的是（段基址/4）的值；在保护模式下载，段寄存器存储的是段选择子，即全局段描述符表（GDTR）的索引。而段基址实际存储在段描述符中（每个段寄存器总是绑定这一个48位的段描述符寄存器（SDR）），其次全局段描述符记录了每一个段描述符。我们应该考虑的是通过什么访问从全局描述符表中获取对应的段描述符加载到段描述符寄存器中。其过程可以通过下面的示意图来说明：
![](https://github.com/null-007/null-007.github.io/img/2019_05_05/getSD.png)
可以看出，段描述符表是存储在内存中的，GDTR记录了段描述符表的起始地址。
其中GTDR：
![](https://github.com/null-007/null-007.github.io/img/2019_05_05/GTDR.png)
DS:
![](https://github.com/null-007/null-007.github.io/img/2019_05_05/DS.png)

## How——保护模式的实现方式
How应该从Why出发，其实在Why中How的总体架构已经出现，剩下的就是实现细节。当然细节也有主次之分。很显然，Why的架构对于我了解保护模式已经足够，因此对How也就无需做更深入的理解了。
 

